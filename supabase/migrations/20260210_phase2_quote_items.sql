-- =====================================================
-- Phase 2: quote_items Table (Gap #1)
-- Foundation for per-item quote pricing
-- =====================================================

-- =====================================================
-- Create quote_items Table
-- =====================================================

CREATE TABLE IF NOT EXISTS quote_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  quote_id UUID NOT NULL REFERENCES quotes(id) ON DELETE CASCADE,
  rfq_item_id UUID NOT NULL REFERENCES rfq_items(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id),
  unit_price DECIMAL(12, 2) NOT NULL CHECK (unit_price >= 0),
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  line_total DECIMAL(12, 2) GENERATED ALWAYS AS (unit_price * quantity) STORED,
  margin_percent DECIMAL(5, 2),
  final_unit_price DECIMAL(12, 2),
  final_line_total DECIMAL(12, 2),
  alternative_product_id UUID REFERENCES products(id),
  is_quoted BOOLEAN NOT NULL DEFAULT TRUE,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add comment to table
COMMENT ON TABLE quote_items IS 
  'Per-item pricing breakdown for multi-item RFQ quotes. Replaces aggregate pricing on quotes table.';

-- =====================================================
-- Create Indexes
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_quote_items_quote_id ON quote_items(quote_id);
CREATE INDEX IF NOT EXISTS idx_quote_items_rfq_item_id ON quote_items(rfq_item_id);
CREATE INDEX IF NOT EXISTS idx_quote_items_product_id ON quote_items(product_id);
CREATE INDEX IF NOT EXISTS idx_quote_items_alternative_product_id ON quote_items(alternative_product_id) 
  WHERE alternative_product_id IS NOT NULL;

-- =====================================================
-- Add type Column to quotes Table
-- =====================================================

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'quotes' AND column_name = 'type'
  ) THEN
    ALTER TABLE quotes ADD COLUMN type TEXT DEFAULT 'custom' 
      CHECK (type IN ('auto', 'custom'));
  END IF;
END $$;

COMMENT ON COLUMN quotes.type IS 
  'Quote type: auto (generated by system) or custom (manually created by supplier)';

-- =====================================================
-- Trigger: Calculate Final Prices on quote_items
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_quote_item_final_prices()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_margin DECIMAL(5, 2);
BEGIN
  -- Use item-level margin if set, otherwise inherit from quote
  IF NEW.margin_percent IS NULL THEN
    SELECT margin_percent INTO v_margin FROM quotes WHERE id = NEW.quote_id;
    NEW.margin_percent := COALESCE(v_margin, 0);
  END IF;
  
  -- Calculate final_unit_price = unit_price * (1 + margin_percent / 100)
  NEW.final_unit_price := NEW.unit_price * (1 + NEW.margin_percent / 100);
  
  -- Calculate final_line_total = final_unit_price * quantity
  NEW.final_line_total := NEW.final_unit_price * NEW.quantity;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop and recreate trigger to ensure idempotency
DROP TRIGGER IF EXISTS trg_calculate_quote_item_final_prices ON quote_items;

CREATE TRIGGER trg_calculate_quote_item_final_prices
  BEFORE INSERT OR UPDATE ON quote_items
  FOR EACH ROW
  EXECUTE FUNCTION calculate_quote_item_final_prices();

COMMENT ON FUNCTION calculate_quote_item_final_prices() IS 
  'Auto-calculates final_unit_price and final_line_total based on margin_percent. Inherits margin from quote if not set.';

-- =====================================================
-- Trigger: Sync Quote Totals from quote_items
-- =====================================================

CREATE OR REPLACE FUNCTION sync_quote_totals()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_quote_id UUID;
  v_supplier_price DECIMAL(12, 2);
  v_final_price DECIMAL(12, 2);
BEGIN
  -- Determine which quote to update
  IF TG_OP = 'DELETE' THEN
    v_quote_id := OLD.quote_id;
  ELSE
    v_quote_id := NEW.quote_id;
  END IF;
  
  -- Calculate totals from all quote_items for this quote
  SELECT 
    COALESCE(SUM(line_total), 0),
    COALESCE(SUM(final_line_total), 0)
  INTO v_supplier_price, v_final_price
  FROM quote_items
  WHERE quote_id = v_quote_id AND is_quoted = TRUE;
  
  -- Update the quote table
  UPDATE quotes
  SET 
    supplier_price = v_supplier_price,
    final_price = v_final_price,
    updated_at = NOW()
  WHERE id = v_quote_id;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Drop and recreate trigger to ensure idempotency
DROP TRIGGER IF EXISTS trg_sync_quote_totals_insert ON quote_items;
DROP TRIGGER IF EXISTS trg_sync_quote_totals_update ON quote_items;
DROP TRIGGER IF EXISTS trg_sync_quote_totals_delete ON quote_items;

CREATE TRIGGER trg_sync_quote_totals_insert
  AFTER INSERT ON quote_items
  FOR EACH ROW
  EXECUTE FUNCTION sync_quote_totals();

CREATE TRIGGER trg_sync_quote_totals_update
  AFTER UPDATE ON quote_items
  FOR EACH ROW
  EXECUTE FUNCTION sync_quote_totals();

CREATE TRIGGER trg_sync_quote_totals_delete
  AFTER DELETE ON quote_items
  FOR EACH ROW
  EXECUTE FUNCTION sync_quote_totals();

COMMENT ON FUNCTION sync_quote_totals() IS 
  'Keeps quotes.supplier_price and quotes.final_price in sync with SUM of quote_items. Only includes is_quoted=TRUE items.';

-- =====================================================
-- Enable RLS on quote_items
-- =====================================================

ALTER TABLE quote_items ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- RLS Policies for quote_items
-- =====================================================

-- Policy: Suppliers can view their own quote items
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Suppliers can view own quote items'
  ) THEN
    CREATE POLICY "Suppliers can view own quote items" ON quote_items
    FOR SELECT
    USING (
      EXISTS (
        SELECT 1 FROM quotes
        WHERE quotes.id = quote_items.quote_id
        AND quotes.supplier_id = auth.uid()
      )
    );
  END IF;
END $$;

-- Policy: Clients can view quote items for quotes sent to them
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Clients can view quote items for sent quotes'
  ) THEN
    CREATE POLICY "Clients can view quote items for sent quotes" ON quote_items
    FOR SELECT
    USING (
      EXISTS (
        SELECT 1 FROM quotes
        JOIN rfqs ON rfqs.id = quotes.rfq_id
        WHERE quotes.id = quote_items.quote_id
        AND rfqs.client_id = auth.uid()
        AND quotes.status IN ('SENT_TO_CLIENT', 'ACCEPTED')
      )
    );
  END IF;
END $$;

-- Policy: Admins can view all quote items
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Admins can view all quote items'
  ) THEN
    CREATE POLICY "Admins can view all quote items" ON quote_items
    FOR SELECT
    USING (get_user_role() = 'ADMIN');
  END IF;
END $$;

-- Policy: Suppliers can insert their own quote items
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Suppliers can insert own quote items'
  ) THEN
    CREATE POLICY "Suppliers can insert own quote items" ON quote_items
    FOR INSERT
    WITH CHECK (
      EXISTS (
        SELECT 1 FROM quotes
        WHERE quotes.id = quote_items.quote_id
        AND quotes.supplier_id = auth.uid()
      )
    );
  END IF;
END $$;

-- Policy: Suppliers can update their own quote items
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Suppliers can update own quote items'
  ) THEN
    CREATE POLICY "Suppliers can update own quote items" ON quote_items
    FOR UPDATE
    USING (
      EXISTS (
        SELECT 1 FROM quotes
        WHERE quotes.id = quote_items.quote_id
        AND quotes.supplier_id = auth.uid()
      )
    );
  END IF;
END $$;

-- Policy: Admins can modify all quote items
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'quote_items' 
    AND policyname = 'Admins can modify all quote items'
  ) THEN
    CREATE POLICY "Admins can modify all quote items" ON quote_items
    FOR ALL
    USING (get_user_role() = 'ADMIN');
  END IF;
END $$;

-- =====================================================
-- Verification Queries
-- =====================================================

-- Verify table was created
DO $$
BEGIN
  ASSERT (SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'quote_items') = 1,
    'quote_items table not created';
END $$;

-- Verify indexes were created
DO $$
BEGIN
  ASSERT (SELECT COUNT(*) FROM pg_indexes WHERE tablename = 'quote_items') >= 4,
    'Not all indexes created on quote_items';
END $$;

-- Verify triggers were created
DO $$
BEGIN
  ASSERT (SELECT COUNT(*) FROM pg_trigger WHERE tgname LIKE 'trg_%quote%') >= 4,
    'Not all triggers created for quote_items';
END $$;

-- Verify RLS is enabled
DO $$
BEGIN
  ASSERT (SELECT relrowsecurity FROM pg_class WHERE relname = 'quote_items') = TRUE,
    'RLS not enabled on quote_items';
END $$;

-- Verify RLS policies were created
DO $$
BEGIN
  ASSERT (SELECT COUNT(*) FROM pg_policies WHERE tablename = 'quote_items') >= 6,
    'Not all RLS policies created for quote_items';
END $$;
